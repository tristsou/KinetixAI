"""
Model 4: IMU Student Model Trained on S-round Pseudo Labels

Goal:
- Use pseudo labels generated by Model 3 on S-round v3d windows
  as "true" labels for S-round IMU windows.
- Train a new Transformer model that uses IMU data (instead of
  MoCap markers) to predict the motion labels.

Assumptions:
- You have already run Model 3 and generated a CSV like:
    pseudo_labels_FtoS_model3_motionnames.csv
  with columns:
    subject_id, center_frame, pred_label_id, pred_label_name

- S-round IMU files are stored as:
    S_IMU_Subject_{sid}.mat  (or S_imu_Subject_{sid}.mat)

- Each IMU .mat file contains a 2D array of shape:
    (n_frames, n_channels)
  accessible via one of the keys in `load_imu_from_mat()`.
  You MUST adjust that function to match your actual .mat structure.
"""

import os
import glob
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader, random_split
from scipy.io import loadmat
from sklearn.metrics import confusion_matrix, classification_report
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# ============================================================
# CONFIG
# ============================================================

DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
DEVICE = "mps"  # for Apple Silicon; comment out if on Windows/Linux GPU

WINDOW_SEC = 1.5
STEP_SEC = 0.5
FS = 120.0
T = int(round(WINDOW_SEC * FS))

BATCH_SIZE = 64
NUM_EPOCHS = 200
LR = 1e-4
VAL_RATIO = 0.2

D_MODEL = 128
NHEAD = 8
NUM_LAYERS = 4
DIM_FF = 256
DROPOUT = 0.1

# ====== EDIT THESE BASED ON YOUR MACHINE ======
DATA_DIR_S_IMU = "/Users/edmundtsou/Projects/S_IMU/"  # root folder for S-round IMU .mat
PSEUDO_LABEL_CSV = "pseudo_labels_FtoS_model3_motionnames.csv"

# Student checkpoint
STUDENT_CKPT_PATH = f"model4_student_transformer_IMU_epoch{NUM_EPOCHS}.pt"


# ============================================================
# DATASET CLASSES
# ============================================================

class IMURoundDataset(Dataset):
    """Windows + labels for training on S-round IMU."""
    def __init__(self, windows, labels):
        self.X = torch.tensor(windows, dtype=torch.float32)
        self.y = torch.tensor(labels, dtype=torch.long)

    def __len__(self):
        return self.X.shape[0]

    def __getitem__(self, idx):
        return {"input_values": self.X[idx], "labels": self.y[idx]}


# ============================================================
# POSITIONAL ENCODING
# ============================================================

class PositionalEncoding(nn.Module):
    def __init__(self, d_model, max_len=2000):
        super().__init__()
        pe = torch.zeros(max_len, d_model)
        pos = torch.arange(0, max_len).unsqueeze(1).float()
        div = torch.exp(torch.arange(0, d_model, 2).float() *
                        (-np.log(10000.0) / d_model))

        pe[:, 0::2] = torch.sin(pos * div)
        pe[:, 1::2] = torch.cos(pos * div)
        pe = pe.unsqueeze(1)
        self.register_buffer("pe", pe)

    def forward(self, x):
        # x: (T, B, D)
        return x + self.pe[:x.size(0)]


# ============================================================
# TRANSFORMER CLASSIFIER  (same as Model 3 for consistency)
# ============================================================

class IMUTransformerClassifier(nn.Module):
    def __init__(self, input_dim, d_model, nhead, num_layers, dim_ff, num_classes):
        super().__init__()
        self.input_proj = nn.Linear(input_dim, d_model)
        self.pos_encoder = PositionalEncoding(d_model)

        enc_layer = nn.TransformerEncoderLayer(
            d_model=d_model,
            nhead=nhead,
            dim_feedforward=dim_ff,
            dropout=DROPOUT,
            batch_first=False,
        )
        self.encoder = nn.TransformerEncoder(enc_layer, num_layers=num_layers)

        self.cls_head = nn.Sequential(
            nn.LayerNorm(d_model),
            nn.Linear(d_model, num_classes)
        )

        self.num_classes = num_classes

    def forward(self, input_values, labels=None):
        # input_values: (B, T, C)
        B, T, C = input_values.shape
        x = self.input_proj(input_values)   # (B, T, D)
        x = x.transpose(0, 1)              # (T, B, D)
        x = self.pos_encoder(x)
        enc = self.encoder(x)              # (T, B, D)
        pooled = enc.mean(dim=0)           # (B, D)
        logits = self.cls_head(pooled)     # (B, num_classes)

        loss = None
        if labels is not None:
            loss = nn.CrossEntropyLoss()(logits, labels)
        return {"loss": loss, "logits": logits}


# ============================================================
# CONFUSION MATRIX (same style as Model 3)
# ============================================================

def compute_confusion_matrix(model, loader, class_names=None):
    model.eval()
    preds, trues = [], []

    with torch.no_grad():
        for batch in loader:
            X = batch["input_values"].to(DEVICE)
            y = batch["labels"].cpu().numpy()
            out = model(X)["logits"].cpu().numpy()
            preds.extend(np.argmax(out, axis=1))
            trues.extend(y)

    trues = np.array(trues)
    preds = np.array(preds)

    print("\nClassification Report:")
    if class_names is not None:
        unique_classes = np.unique(np.concatenate([trues, preds]))
        label_names = [class_names[i] for i in unique_classes]
        print(
            classification_report(
                trues,
                preds,
                labels=unique_classes,
                target_names=label_names,
                digits=3,
            )
        )
        cm = confusion_matrix(trues, preds, labels=unique_classes)
    else:
        print(classification_report(trues, preds, digits=3))
        cm = confusion_matrix(trues, preds)

    plt.figure(figsize=(10, 8))
    sns.heatmap(cm, cmap="Blues", annot=False)
    plt.title("Student Confusion Matrix (S-round IMU)")
    plt.xlabel("Predicted")
    plt.ylabel("True")
    plt.show()


# ============================================================
# IMU LOADING HELPERS  *** ADAPT THIS TO YOUR .MAT FILES ***
# ============================================================

def load_imu_from_mat(path):
    """
    Load S1 IMU array from imu_Subject_*.mat.

    We ONLY use S1_Synched because Model 3 pseudo labels come from
    the S1 round (S-round S1).

    Returns:
        imu_arr: np.ndarray of shape (n_frames, n_channels)
        or None if S1_Synched is not present (caller should skip).
    """
    mat = loadmat(path, struct_as_record=False, squeeze_me=False)
    if "IMU" not in mat:
        print(f"[WARN] 'IMU' key not found in {path}, skipping.")
        return None

    imu_root = mat["IMU"][0, 0]

    if not hasattr(imu_root, "S1_Synched"):
        print(f"[WARN] No S1_Synched in {os.path.basename(path)}, skipping this subject.")
        return None

    seg = imu_root.S1_Synched[0, 0]
    imu_arr = np.asarray(seg.data)  # expected (n_frames, n_channels)

    if imu_arr.ndim != 2:
        print(
            f"[WARN] Expected 2D IMU array in {path}, got shape {imu_arr.shape}; skipping."
        )
        return None

    return np.nan_to_num(imu_arr)  # (n_frames, n_channels)


# ============================================================
# BUILD S-ROUND IMU WINDOWS + LABELS FROM PSEUDO CSV
# ============================================================

def build_sround_imu_windows_and_labels_from_pseudo(
    data_dir_imu,
    pseudo_csv,
    window_sec=WINDOW_SEC,
    step_sec=STEP_SEC,
    fs=FS,
):
    """
    - Loads pseudo labels from Model 3 CSV (subject_id, center_frame, pred_label_name).
    - Loads S-round IMU .mat files.
    - Builds sliding windows (same scheme as Model 3) and
      assigns each window the pseudo label whose (subject_id, center_frame)
      matches.

    Returns:
        windows: (N, T_frames, n_channels)
        labels:  (N,)
        class_names: list[str], sorted unique label names
    """
    # --- 1) Load pseudo labels ---
    df = pd.read_csv(pseudo_csv)
    if not {"subject_id", "center_frame", "pred_label_name"}.issubset(df.columns):
        raise ValueError(
            "Pseudo label CSV must contain columns: "
            "'subject_id', 'center_frame', 'pred_label_name'"
        )

    # Use label NAMES as the canonical classes (IDs can be re-mapped)
    all_label_names = df["pred_label_name"].astype(str).values
    class_names = sorted(np.unique(all_label_names))
    name_to_id = {name: i for i, name in enumerate(class_names)}

    # Map (sid, center_frame) -> label_name
    label_map = {}
    for sid, cf, lbl in zip(df["subject_id"], df["center_frame"], all_label_names):
        key = (str(sid), int(cf))
        label_map[key] = lbl

    print(f"Loaded pseudo labels from {pseudo_csv}")
    print(f"Num pseudo windows: {len(df)}")
    print(f"Num classes (from pseudo labels): {len(class_names)}")
    print("class_names:", class_names)

    # --- 2) Find S-round IMU files ---
    patterns = [
        os.path.join(data_dir_imu, "imu_Subject_*.mat"),
    ]
    paths = []
    for pat in patterns:
        paths.extend(glob.glob(pat))
    paths = sorted(paths)

    if not paths:
        raise FileNotFoundError(
            f"No S-round IMU .mat files found in {data_dir_imu} "
            "with patterns S_IMU_Subject_*.mat or S_imu_Subject_*.mat"
        )

    T_frames = int(round(window_sec * fs))
    step = int(round(step_sec * fs))

    X_all = []
    y_all = []

    total_windows = 0
    matched_windows = 0

    for p in paths:
        print(f"[S-round IMU] Loading {p}")
        imu_arr = load_imu_from_mat(p)      # (n_frames, n_channels) or None

        if imu_arr is None:
            # No usable S1_Synched for this subject; skip entirely
            continue

        n_frames, n_channels = imu_arr.shape
        sid = p.split("Subject_")[-1].split(".")[0]

        for s in range(0, n_frames - T_frames, step):
            e = s + T_frames
            c = s + T_frames // 2
            total_windows += 1

            key = (str(sid), int(c))
            if key not in label_map:
                continue  # no pseudo label for this window

            lbl_name = label_map[key]
            lbl_id = name_to_id[lbl_name]

            win = imu_arr[s:e, :]   # (T_frames, n_channels)
            X_all.append(win)
            y_all.append(lbl_id)
            matched_windows += 1

    if not X_all:
        raise RuntimeError(
            "No IMU windows matched pseudo labels. "
            "Check that your IMU frame counts and FS align with v3d, and "
            "that subject_id / center_frame conventions match Model 3."
        )

    windows = np.stack(X_all)
    labels = np.array(y_all, dtype=np.int64)

    # ------------------------------
    # PER-CHANNEL NORMALIZATION (NEW)
    # ------------------------------
    # windows: (N, T, C)
    C = windows.shape[2]

    # Compute mean + std across ALL windows, ALL time steps
    mean = windows.reshape(-1, C).mean(axis=0)        # (C,)
    std  = windows.reshape(-1, C).std(axis=0) + 1e-8  # (C,)

    # Normalize
    windows = (windows - mean) / std

    print("Applied per-channel normalization:")
    print(" mean shape:", mean.shape)
    print(" std shape:", std.shape)


    print("====================================================")
    print("Built S-round IMU windows with pseudo labels:")
    print(" total_windows_considered:", total_windows)
    print(" matched_windows (used):", matched_windows)
    print(" windows shape:", windows.shape)
    print(" labels shape:", labels.shape)
    print(" num_classes:", len(class_names))
    print("====================================================")

    return windows, labels, class_names


# ============================================================
# TRAIN STUDENT ON S-ROUND IMU
# ============================================================

def train_student_model_imu(windows, labels, num_classes, class_names=None):
    dataset = IMURoundDataset(windows, labels)
    n_total = len(dataset)
    n_val = int(n_total * VAL_RATIO)
    n_train = n_total - n_val

    train_ds, val_ds = random_split(dataset, [n_train, n_val])
    train_loader = DataLoader(train_ds, batch_size=BATCH_SIZE, shuffle=True)
    val_loader = DataLoader(val_ds, batch_size=BATCH_SIZE)

    model = IMUTransformerClassifier(
        input_dim=windows.shape[2],
        d_model=D_MODEL,
        nhead=NHEAD,
        num_layers=NUM_LAYERS,
        dim_ff=DIM_FF,
        num_classes=num_classes
    ).to(DEVICE)

    optim = torch.optim.AdamW(model.parameters(), lr=LR)

    for epoch in range(NUM_EPOCHS):
        total_loss = 0.0
        model.train()

        for batch in train_loader:
            X = batch["input_values"].to(DEVICE)
            y = batch["labels"].to(DEVICE)

            out = model(X, y)
            loss = out["loss"]

            optim.zero_grad()
            loss.backward()
            optim.step()

            total_loss += loss.item() * X.size(0)

        avg_loss = total_loss / n_train

        # Validation accuracy
        correct, total = 0, 0
        model.eval()
        with torch.no_grad():
            for batch in val_loader:
                X = batch["input_values"].to(DEVICE)
                y = batch["labels"].to(DEVICE)
                preds = torch.argmax(model(X)["logits"], dim=1)
                correct += (preds == y).sum().item()
                total += y.size(0)

        val_acc = correct / total if total > 0 else 0.0
        print(f"Epoch {epoch+1}/{NUM_EPOCHS} | Loss={avg_loss:.4f} | ValAcc={val_acc:.4f}")

    # Confusion matrix on validation set
    compute_confusion_matrix(model, val_loader, class_names=class_names)
    return model


# ============================================================
# MAIN
# ============================================================

if __name__ == "__main__":
    print(">>> Model 4 (IMU Student) Starting")
    print(f">>> Using device: {DEVICE}")

    # 1) Build S-round IMU windows + labels using pseudo labels from Model 3
    print(">>> Building S-round IMU windows from pseudo labels...")
    Xs_imu, ys_imu, class_names = build_sround_imu_windows_and_labels_from_pseudo(
        data_dir_imu=DATA_DIR_S_IMU,
        pseudo_csv=PSEUDO_LABEL_CSV,
        window_sec=WINDOW_SEC,
        step_sec=STEP_SEC,
        fs=FS,
    )
    num_classes = len(class_names)

    # 2) Train student model on IMU
    print(">>> Training IMU student model on pseudo-labeled S-round data...")
    student = train_student_model_imu(
        Xs_imu,
        ys_imu,
        num_classes=num_classes,
        class_names=class_names,
    )

    # 3) Save student checkpoint
    torch.save(
        {
            "state_dict": student.state_dict(),
            "class_names": class_names,
        },
        STUDENT_CKPT_PATH
    )
    print(f">>> Saved IMU student model â†’ {STUDENT_CKPT_PATH}")
    print(">>> Model 4 Done.")
